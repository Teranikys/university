# Практическая работа 1

## Задание

По результатам структуризации требований и их декомпозиции
необходимо выбрать один из видов монолитной архитектуры и
описать причины выбора именно данного/данных подходов к
проектированию АС.

Опираясь на те же аналитические документы необходимо
выбрать целевую архитектуру, АС с обоснованием выбора
подхода/подходов к проектированию АС.
В обоих случаях следует описать:

 1. Риски использования данного подхода;

 2. Преимущества использования данного подхода;

 3. Основные факторы, повлиявшие на выбор данного подхода.

Защитить свое решение на паре.

 Создаваемые артефакты:

 1. Архитектурное решение по проектированию АС в монолите и
описания из пунктов выше;

 2. Архитектурное решение по проектированию АС в целевой
архитектуре и описания из пунктов выше.

## Требования

Основные требования:

- Отчёт на русском языке;
- Официальный стиль;
- Кратко и по делу;
– Стараться избегать списков. Вместо них предпочтительнее использовать связные текст.

## Контекст

1.1. Функциональные требования
1.1.1. Модуль управления данными
• Пользователь должен иметь возможность загружать объект, выбрав для него класс хранения;
• Пользователь должен иметь возможность копировать объект, с опци-ональной возможностью изменить класс хранения для создаваемой копии;
• Пользователь должен иметь возможность удалять объект;
• Пользователь должен иметь возможность настраивать ACL объекта, для чего необходимо выбрать владельца правила и соответствующее разрешение.
1.1.2. Модуль управления хранилищем
• Пользователь должен иметь возможность просматривать список баке-тов;
• Пользователь должен иметь возможность создавать бакет;
• Пользователь должен иметь возможность удалять бакет;
• Пользователь должен иметь возможность просматривать список объ-ектов в бакете;
• Пользователь должен иметь возможность просматривать настройки бакета;
• Пользователь должен иметь возможность изменять ограничение на объём бакета;
• Пользователь должен иметь возможность изменять класс хранения по умолчанию для бакета;
• Пользователь должен иметь возможность включать версионирование для бакета;
• Пользователь должен иметь возможность управлять политикой досту-па бакета;
• Пользователь должен иметь возможность включать блокировку объек-тов в бакете;
• Пользователь должен иметь возможность просматривать правила жизненного цикла бакета;
• Пользователь должен иметь возможность создавать правило жизнен-ного цикла для бакета;
• Пользователь должен иметь возможность изменять правило жизнен-ного цикла бакета;
• Пользователь должен иметь возможность удалять правило жизненно-го цикла бакета;
• Пользователь должен иметь возможность настраивать ACL бакета, вы-бирая владельца правила и разрешение.
1.2. Нефункциональные требования
Нефункциональные требования, представленые в таблице 1, опреде-ляют, как система должна выполнять свои функции. Они задают общие ат-рибуты качества, такие как производительность, надежность и безопасность, которые являются критически важными для облачного хранилища.
Таблица 1 – Нефункциональные требования
Название Требование Атрибуты качества
Масштаби-руемость Система должна быть горизон-тально масштабируема как для роста объёма хранилища, так и для роста пользовательской нагрузки. Горизонтальная масштабируе-мость: Добавление новых узлов хране-ния должно линейно увеличивать об-щую емкость и производительность.
Доступ-ность Система должна обеспечивать высокий уровень доступности данных, минимизируя время простоя. Uptime: SLA не менее 99.9% време-ни. Отказоустойчивость: Выход из строя компонента не должен приводить к потере данных.
Производи-тельность Система должна обеспечивать низкую задержку при доступе к данным (чтение/запись). Latency: Среднее время ответа на запрос GET для "горячих" данных < 20 мс(время от получения запроса до от-правки ответа).
Надежность и сохран-ность дан-ных Система должна гарантировать сохранность данных с очень вы-сокой вероятностью. Data Durability: 99.999% (пять девяток). Достигается за счет избыточности (ре-пликации) данных.
Безопас-ность Система должна защищать дан-ные от несанкционированного доступа на всех уровнях. Шифрование: Поддержка SSL/TLS и server-side encryption.
Конси-стентность данных Система должна обеспечивать строгую консистентность после записи (strong read-after-write consistency). Корректность: Сразу после успешной операции любой последующий запрос на чтение должен возвращать актуальное состояние.

## Результат

### Ход работы

#### Введение

Для выбора одного из видов монолитной архитектуры необходимо рассмотреть их основные характеристики. Многослойная архитектура обычно состоит из трех основных слоев: слой представления, слой бизнес-логики и слой передачи данных. Слой представления отвечает за взаимодействие с пользователем, слой бизнес-логики обрабатывает данные в соответствии с бизнес-правилами, а слой передачи данных отвечает за взаимодействие с базами данных и другими источниками данных. Многоуровневая архитектура позволяет разместить разные слои на разных физических серверах. Так, слой базы данных может быть на отдельном сервере, слой бизнес-логики на другом, а слой пользовательского интерфейса – на третьем. Распределённая архитектура приложения предполагает размещение различных компонентов приложения на разных физических или виртуальных машинах. Вместо того чтобы сконцентрировать все задачи на одном сервере, работа делится между множеством нод. Модульный монолит – такой архитектурный подход, который позволяет проектировать архитектурную систему с учетом модулей. Приложение разбивается на более мелкие независимые модули, каждый из которых отвечает за определённую функциональность или бизнес-область. Справедливо заметить, что при проектировании и разработке программного обеспечения используется «гибридный» подход, в рамках которого комбинируются элементы разных видов архитектуры. Я, в свою очередь, хотела бы остановиться на модульном монолите.

#### Модульный монолит
##### Риски использования модульного монолита
*	Сложность внесения модификаций в отдельные модули системы из-за взаимосвязанности компонентов
*	Трудности перехода на новые технологии и язык программирования. Если захочется сменить язык программирования, потребуется переписать приложение целиком, а это долго и дорого.
*	Необходимость обращения модуля к участку кода другого модуля из-за невозможности создания абсолютно независимых и взаимозаменяемых модулей
*	Риск неработоспособности приложения из-за возникновения ошибки в уязвимом месте модуля
*	Проблемы с производительностью из-за увеличенной нагрузки на систему

##### Преимущества модульного монолита
*	Модули соответствуют отдельным бизнес-функциям или процессам
*	Упрощенное взаимодействие модулей. Нет необходимости в настройке сложной инфраструктуры для сетевого взаимодействия или балансировки нагрузки
*	Простой переход к микросервисной архитектуре при возникновении необходимости в горизонтальном масштабировании
*	Низкие затраты на интеграцию новых компонентов
*	Легкое разворачивание как единое целое без риска ошибок конфигурации
*	Простая отладка с доступом к необходимым логам и данным конкретного модуля

##### Основные факторы выбора модульного монолита
*	Необходимость быстрой разработки и деплоя приложения
*	Ограниченный бюджет проекта, требующего экономичное решение
*	Проект подразумевает разделение функционала на модули
*	Проект небольшого размера, который в будущем может расшириться и перейти от модульного монолита к микросервисной архитектуре

#### Целевая архитектура
Микросервисная архитектура предполагает построение приложения в виде набора слабо связанных между собой компонентов («микросервисов»). Микросервисную архитектуру отличают два основных принципа — слабая связанность и единая ответственность.

##### Риски использования микросервисной архитектуры
*	Сложности выявление проблем в определенной части приложения без специальных средств мониторинга ввиду того, что микросервисное приложение может продолжать работу, если процесс не затрагивает уязвимое место.
*	Усложнение процедуры установки приложения. Не получится ограничиться одним сервером приложений и одним сервером баз данных, понадобится много — для каждого микросервиса.
*	Обработка запроса пользователя требует вызов нескольких микросервисов в определённом порядке. Для этого создают новые компоненты, увеличение которых усложняет архитектуру.
*	Усложнение архитектуры приложения за счет увеличения числа компонентов и правил их взаимодействия

##### Преимущества микросервисной архитектуры
*	Наличие отдельного хранилища данных для каждого сервиса
*	Высокая производительность приложения и низкие затраты на аппаратное обеспечение
*	Легкость внесения изменений в отдельный сервис приложения
*	Каждый компонент может масштабироваться отдельно, позволяя настраивать масштабирование в зависимости от потребностей продукта
*	Независимые разработка, тестирование и развертывание микросервисов  делает возможным внедрение непрерывной доставки и развёртывания приложения

##### Основные факторы выбора микросервисной архитектуры
*	Необходимость внесения изменений в отдельные части приложения
*	Возможность выбрать для каждого микросервиса подходящую для него технологию и язык программировании
*	Возможные сбои в работе одного сервиса не затронут систему целиком
*	Необходимость в гибком масштабировании компонентов
*	Требование ко времени передачи данных для выполнения запроса клиента (100 ms)
